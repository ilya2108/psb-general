# Механизм исполнения операций банка на основе микросервисной архитектуры

В этом репозитории описано решение кейса **Механизм исполнения операций банка на основе микросервисной архитектуры**. В этом репозитории будет описана предлагаемая арзитектура и дизайн решения, а так же ссылки на части кода.

## Содержание

* [Цели](https://github.com/ilya2108/psb-general#%D1%86%D0%B5%D0%BB%D0%B8)
* [Архитектурные решения](https://github.com/ilya2108/psb-general#%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B5-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)
* [Контекстная диаграмма](https://github.com/ilya2108/psb-general#%D0%BA%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%BD%D0%B0%D1%8F-%D0%B4%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0)
* [Референсные архитектуры и паттерны](https://github.com/ilya2108/psb-general#%D1%80%D0%B5%D1%84%D0%B5%D1%80%D0%B5%D0%BD%D1%81%D0%BD%D1%8B%D0%B5-%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B8-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B)
* [Взаимодействие компонентов](https://github.com/ilya2108/psb-general#%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B5-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)
* [Дизайн решения](https://github.com/ilya2108/psb-general#%D0%B4%D0%B8%D0%B7%D0%B0%D0%B9%D0%BD-%D1%80%D0%B5%D1%88%D0%B5%D0%BD%D0%B8%D1%8F)
* [Инструкция к запуску](https://github.com/ilya2108/psb-general#%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D1%8F-%D0%BA-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA%D1%83)
* [Полезные ссылки](https://github.com/ilya2108/psb-general#%D0%BF%D0%BE%D0%BB%D0%B5%D0%B7%D0%BD%D1%8B%D0%B5-%D1%81%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)
* [Рекомендации разработчикам](https://github.com/ilya2108/psb-general#%D1%80%D0%B5%D0%BA%D0%BE%D0%BC%D0%B5%D0%BD%D0%B4%D0%B0%D1%86%D0%B8%D0%B8-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B0%D0%BC)

## Цели

Целью задачи является создание ядра системы исполнения операций банка, которое должно соответствовать нескольким архитектурным принципам:

* Предложенное решение должно быть на основе **микросервисной архитектуры**;
* Для распределенного выполнения операции должна использоваться **событийно-ориентированная архитектура**;
* Решение должно быть в стеке языков программирования **C# или Java**;
* Для улучшения работы команды необходимо внедрить технологии **CI/CD**, которые позволят автоматизировать часть процессов.

## Архитектурные решения

На основе вышеуказанных архитектурных принципов должны быть приняты соответствующие архитектурные решения. Таким образом, решение должно обладать следующим набором свойств:

* Грамотная микросервисная архитектура должна обладать несколькими важнейшими качествами: **сильное зацепление** и **низкая связанность**. Сильное зацепление отвечает за то, чтобы каждый компонент делал **только за свою задачу** и **общался с другими сервисами** для выполнения функционала более высокого уровня (где используется больше одного сервиса). В то же время, низкая связанность отражает то, что микросервисы **не имеют сильной зависимости друг от друга**. Это позволяет разрабатывать каждый компонент экосистемы независимо;
* Наличие большого числа микросервисов и стремление к отказоустойчивости приводит к мысли об **использовании технологии оркестрации**, такой как [Kubernetes](https://kubernetes.io/);
* Поскольку использование Java является принципиальным, а Kubernetes - необходимым, то можно предложить технологию [Quarkus](https://quarkus.io/) для реализации серверной части. Помимо того, что эта среда является родной для Kubernetes, она еще и гораздо более **эффективна по памяти** (более чем в 10 раз) и **скорости** (более чем в 225 раз) по сравнению с традиционным облако-ориентированным стеком технологий.

## Контекстная диаграмма

![alt text](Context%20Diagram.png)

Здесь представлена контектсная диаграмма решения. В ней задействованы три возможные роли: **клиент** (конечный пользователь), **сотрудник банка**, обслуживающий клиента, и **техническая поддержка**, которая следит за качеством работы сервиса. Сама система имеет несколько подсистем:

* **Регистрация операции**. Эта подсистема отвечает за помощь в динамической отрисовке UI и регистрации операций. После выполнения регистрации они попадают в подсистему *обработки операций*;
* **Обработка операции**. Компонент отвечает за контроль очередью операций и за их асинхронное выполнение. Более того, все действия с операциями попадают в подсистему *общего журналирования*, суть которой будет разъяснена ниже;
* **Журналирование операций**. Данный модуль отвечает за ведение журнала работы с операциями. Он фиксирует все действия, которые были осуществлены в рамках той или иной операции. Он будет активно использоваться в системе **отмены операции**;
* **Отмена операции**. Этот компонент является одной из главных особенностей системы. Дело в том, что отмена **операции можно проводить даже после ее успешного выполнения**. Поэтому этот сервис был вынесен отдельно.

## Референсные архитектуры и паттерны

Одной из главных вещей при разработке архитектуры решения важны референсные архитектуры и паттерны, которые соответствуют предметной области.

### Микросервисная архитектура

Один из [основных источников](https://microservices.io/) о микросервисной архитектуре определяет ее основные свойства как:

* **Высокая доступность** и тестируемость;
* **Низкая связанность**;
* **Независимо развертываемые компоненты**;
* Сервисы **организованы в соответствии с возможностями бизнеса**;
* Каждый сервис находится под **управлением маленькой команды** (по сравнению с командой по управлению монолитом).

Предлагаю проанализировать каждый пункт. Возможность обеспечить высокую доступность является **одним из преимуществ** технологии [Kubernetes](https://kubernetes.io/). В нем есть процессы управления, которые по факту независимы и компонуемы. Это приводит к тому, что нам неважно какой будет маршрут между сервисами, что исключает централизованный контроль.
Благодаря этому система теперь не только проста в использовании, мощная, надежная, но и устойчивая и расширяемая.

Стоит отметить, что низкая связанность компонентов в архитектуре обеспечивается **слабой зависимостью** одной подсистемы от другой (каждый сервис может выплонять большинство своих задач, если связанные сервисы недоступны). Это же приводит к **независимой развертываемости** сервисов и **уменьшению команды поддержки** каждого сервиса.

Таким образом, можно сделать вывод, что **решение соответствует микросервисному паттерну**.

### Database-per-Service архитектура

[Этот паттерн](https://microservices.io/patterns/data/database-per-service.html) непосредственно вытекает из микросервисной архитектуры, так как отвечает за организацию данных в микросервисах. Более того, использование этого паттерна является **обазятельным для событийно-ориентированной архитектуры**.

Он заключается в том, что **каждый микросервис содержит в себе базу данных**, к которой обращается. Более того, он является **единственным сервисом**, который взаимодействует с этой базой данных.

В решении мы используем этот паттерн, так как у нас есть три базы данных:

* зарегистрированные операции (подсистема **регистрации**),
* операции, выплоненные успешно или выполняемые сейчас (подсистема **обработки**),
* информация о действиях в рамках операциях (подсистема **журналирования**).
  
Только соответствующие подсистемы могут с ними взаимодействовать, из чего можно сделать вывод, что **решение использует Database-per-Service pattern**.

### Событийно-ориентированная архитектура

Особенностью [этой архитектуры](https://microservices.io/patterns/data/event-driven-architecture.html) является то, что **данные могут обрабатываться** несколькими сервисами. Это достигается за счет того, что существует отдельная сущность, отвечающая за **очередь операций, которые ждут выполнения**.

В нашем случае за это отвечает сервис **обработки операции**, в котором помимо своей базы данных (см. Database-per-Service) есть еще и очередь Apache Kafka. Вышеуказанное можно назвать **использованием паттерна событийно-ориентированной архитектуры**.

## Взаимодействие компонентов

Мы поговорили о принятых решениях в рамках проекта и о лучших практиках в индустрии. Теперь настало время посмотреть на взаимодействие между компонентами в двух этапах операции: **регистрация** и **обработка**.

На рисунке ниже представлена диаграмма взаимодействия компонентов при регистрации:

![alt text](Interaction_registration_queue.png)

Здесь важно отметить, какие метаданные мы отправляем в качестве ответа. Мы отправляем **поля операции, которые еще не заполнены**. Это позволит на клиентской стороне выстроить UI таким образом, чтобы **заполнить оставшиеся поля**.

На этом изображении представлена диаграмма взаимодействия компонентов для обработки:

![alt text](Interaction_queue_done.png)

## Дизайн решения

Итак, вишенка на торте: **итоговый дизайн решения**. Он изображен здесь:

![alt text](Solution%20Design.jpg)

Давайте проанализируем каждую часть дизайна:

1. Разработчики делают коммиты в **разные репозитории с сервисами**;
2. Коммит, произведенный в отслеживаемую ветку, запускает CI pipeline, который выполняет две функции: **загрузка изображения в приватное хранилище** и **развертывание в Kubernetes в Azure**;
3. В самом кластере находятся три сервиса. Каждый из них имеет документацию в Swagger:
   * **Регистрация**. Он имеет API, написанный на Quarkus и базу данных PostreSQL;
   * **Обработка**. Стек технологий не отличается от регистрации, разве что появляется Kafka для хранения событий;
   * **Журналирование**. Опять же, реализация похожа на сервис регистрации, но теперь там есть еще инструменты, ускоряющие поиск: ElasticSearch и LogStash (дополняет журнал данными о клиенте).
  
4. Техническая поддержка сможет **следить за состоянием кластера** с помощью ElasticSearch, Kibana, LogStash (ELK);
5. Также есть **пример внешней системы** для того, чтобы эмулировать вызов внешней системы.

Теперь стоит показать наши результаты на примере сервиса регистрации. Мы реализовали для него Swagger документацию, которая выглядит вот так:

![alt text](Swagger.jpg)

При каждом коммите в главную ветку вызывается CI pipeline (файл ```azure-pipelines.yaml```), результат работы которого выглядит вот так:

![alt text](Azure%20DevOps.jpg)

В результате изображение, которое собралось в ходе CI, было отправлено в Azure Container Registry. Вот как это выглядит в портале:

![alt text](ACR.jpg)

И в конце концов контейнер на основе этого изображения был автоматически создан в кластере. Эти все операции заняли около 10 минут, а результат работы выглядит следующим образом:


![alt text](kubectl.jpg)

## Инструкция к запуску

Все три сервиса находятся в отдельных репозиториях. Все три сервиса можно скачать с помощью Docker используя команду:

### Docker compose

1. Необходимо запустить файл ```docker-compose.yaml``` командой ```docker-compose up -d```, находясь в директории с этим файлом. Также в ней должен быть файл ```init_db.sql```, который создает базовые настройки;

2. Сервисы доолжны быть доступны по следующим адресам:
   * ```localhost:5432``` - PostreSQL база данных (каждый микросервис использует там свою базу данных);
   * ```localhost:8084``` - сервис регистрации;

### Kubernetes

Все репозитории содержат два файла, связанных с Kubernetes: ```service.yml``` и ```deployment.yml```. Чтобы запустить кластер уу себя, необходимо **скачать эти файлы из репозиториев** и запустить комманду ```kubectl apply -f service.yml deployment.yml``` для каждого из сервисов.

Так же, важным элементом является **создание сервиса базы данных** по  ```порту 5432```.

В Kubernetes помимо осноовных сервисов запущен и ELK компонента, которая отвечает за мониторинг состояния кластера. Чтобы поставить такой же ELK, то необхдоимо запустить у себя скрипт ```elk.sh```. После запуска Kibana будет открыта по адресу ```$Kibana_External_IP:5601```, где $Kibana_External_IP - внешний IP адрес сервиса Kibana.

## Полезные ссылки

* [GitHub репозиторий сервиса регистрации](https://github.com/ilya2108/psb-registration). Сервис развернут по адресу ```52.177.241.31:8084```;
* ELK для мониторинга кластера в облаке Azure. Kibana, развернутая в этом кластере, доступна по адресу ```20.80.218.103:5601```;
* [Видео работы сервиса регистрации через Swagger](https://youtu.be/yMiT0-sscAw);
* [Демонстрация Azure DevOps, Azure Container Registry и Azure Kubernetes Service](https://youtu.be/U82g-g--FQU)

Возможно, развернутые сервисы могут быть недоступными. Это связано с особенностями работы базы данных в текущей настройке кластера.

## Рекомендации разработчикам

Мы постарались позаботиться о высоком уровне DevEx, поэтому сделали наиболее понятные требования того, что мы требуем от каждой операции. Поэтому мы реализовали **класс ```Operation```, описывающий требуемый функционал**. В нашем видении операция состоит из следующих полей:

* Поля, заполняемые в UI;
* Статус выполнения операции (Регистрация, Обработка, Успешно, Отменено);
* Стек вызова экранов (используется только на этапе регистрации).
